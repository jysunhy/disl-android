diff -uN android-re-agent/A android-re-agent.bak2/A
--- android-re-agent/A	1970-01-01 01:00:00.000000000 +0100
+++ android-re-agent.bak2/A	2013-11-20 09:16:05.300043816 +0100
@@ -0,0 +1,23 @@
+LOCAL_PATH:=$(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE_TAGS :=samples 
+
+LOCAL_MODULE:= libarithmetic 
+
+
+LOCAL_SRC_FILES:= \
+long.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+libutils
+
+#LOCAL_STATIC_LIBRARIES := 
+
+LOCAL_C_INCLUDES += $(JNI_H_INCLUDE)
+
+LOCAL_CFLAGS +=
+
+
+LOCAL_PRELINK_MODULE := false
+include $(BUILD_SHARED_LIBRARY)
diff -uN android-re-agent/buffpack.h android-re-agent.bak2/buffpack.h
--- android-re-agent/buffpack.h	1970-01-01 01:00:00.000000000 +0100
+++ android-re-agent.bak2/buffpack.h	2013-11-20 09:16:05.200093820 +0100
@@ -0,0 +1,98 @@
+#ifndef _BUFFPACK_H
+#define	_BUFFPACK_H
+
+#if defined (__APPLE__) && defined (__MACH__)
+
+#include <machine/endian.h>
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define htobe64(x) (x)
+#else // BYTE_ORDER != BIG_ENDIAN
+#define htobe64(x) __DARWIN_OSSwapInt64((x))
+#endif
+
+#else // !(__APPLE__ && __MACH__)
+#include <endian.h>
+#endif
+
+// GCC has known bug where it does not work always correctly
+//#ifndef __STDC_IEC_559__
+//#error "Requires IEEE 754 floating point!"
+//#endif
+
+
+#include "buffer.h"
+
+// interpret bytes differently
+union float_jint {
+
+	float f;
+	jint i;
+};
+
+// interpret bytes differently
+union double_jlong {
+
+	double d;
+	jlong l;
+};
+
+void pack_boolean(buffer * buff, jboolean to_send) {
+	buffer_fill(buff, &to_send, sizeof(jboolean));
+}
+
+void pack_byte(buffer * buff, jbyte to_send) {
+	buffer_fill(buff, &to_send, sizeof(jbyte));
+}
+
+void pack_char(buffer * buff, jchar to_send) {
+	jchar nts = htons(to_send);
+	buffer_fill(buff, &nts, sizeof(jchar));
+}
+
+void pack_short(buffer * buff, jshort to_send) {
+	jshort nts = htons(to_send);
+	buffer_fill(buff, &nts, sizeof(jshort));
+}
+
+void pack_int(buffer * buff, jint to_send) {
+	jint nts = htonl(to_send);
+	buffer_fill(buff, &nts, sizeof(jint));
+}
+
+void pack_long(buffer * buff, jlong to_send) {
+	jlong nts = htobe64(to_send);
+	buffer_fill(buff, &nts, sizeof(jlong));
+}
+
+void pack_float(buffer * buff, jfloat to_send) {
+	// macro ensures that the formating of the float is correct
+	// so make "int" from it and send it
+	union float_jint convert;
+	convert.f = to_send;
+	pack_int(buff, convert.i);
+}
+
+void pack_double(buffer * buff, jdouble to_send) {
+	// macro ensures that the formating of the double is correct
+	// so make "long" from it and send it
+	union double_jlong convert;
+	convert.d = to_send;
+	pack_long(buff, convert.l);
+}
+
+void pack_string_utf8(buffer * buff, const void * string_utf8,
+		uint16_t size_in_bytes) {
+
+	// send length first
+	uint16_t nsize = htons(size_in_bytes);
+	buffer_fill(buff, &nsize, sizeof(uint16_t));
+
+	buffer_fill(buff, string_utf8, size_in_bytes);
+}
+
+void pack_bytes(buffer * buff, const void * data, jint size) {
+	buffer_fill(buff, data, size);
+}
+
+#endif	/* _BUFFPACK_H */
diff -uN android-re-agent/JniUtility.h android-re-agent.bak2/JniUtility.h
--- android-re-agent/JniUtility.h	1970-01-01 01:00:00.000000000 +0100
+++ android-re-agent.bak2/JniUtility.h	2013-11-20 09:16:05.344021815 +0100
@@ -0,0 +1,95 @@
+#ifndef _BUFFPACK_H
+#define	_BUFFPACK_H
+
+#if defined (__APPLE__) && defined (__MACH__)
+
+#include <machine/endian.h>
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define htobe64(x) (x)
+#else // BYTE_ORDER != BIG_ENDIAN
+#define htobe64(x) __DARWIN_OSSwapInt64((x))
+#endif
+
+#else // !(__APPLE__ && __MACH__)
+#include <endian.h>
+#endif
+
+// GCC has known bug where it does not work always correctly
+//#ifndef __STDC_IEC_559__
+//#error "Requires IEEE 754 floating point!"
+//#endif
+
+#include "Buffer.h"
+
+// interpret bytes differently
+union float_jint {
+	float f;
+	jint i;
+};
+
+// interpret bytes differently
+union double_jlong {
+	double d;
+	jlong l;
+};
+
+void pack_boolean(Buffer * buff, jboolean to_send) {
+	buff->Push(&to_send, sizeof(jboolean));
+}
+
+void pack_byte(Buffer * buff, jbyte to_send) {
+	buff->Push(&to_send, sizeof(jbyte));
+}
+
+void pack_char(Buffer * buff, jchar to_send) {
+	jchar nts = htons(to_send);
+	buff->Push(&nts, sizeof(jchar));
+}
+
+void pack_short(Buffer * buff, jshort to_send) {
+	jshort nts = htons(to_send);
+	buff->Push(&nts, sizeof(jshort));
+}
+
+void pack_int(Buffer * buff, jint to_send) {
+	jint nts = htonl(to_send);
+	buff->Push(&nts, sizeof(jint));
+}
+
+void pack_long(Buffer * buff, jlong to_send) {
+	jlong nts = htobe64(to_send);
+	buff->Push(&nts, sizeof(jlong));
+}
+
+void pack_float(Buffer * buff, jfloat to_send) {
+	// macro ensures that the formating of the float is correct
+	// so make "int" from it and send it
+	union float_jint convert;
+	convert.f = to_send;
+	pack_int(buff, convert.i);
+}
+
+void pack_double(Buffer * buff, jdouble to_send) {
+	// macro ensures that the formating of the double is correct
+	// so make "long" from it and send it
+	union double_jlong convert;
+	convert.d = to_send;
+	pack_long(buff, convert.l);
+}
+
+void pack_string_utf8(Buffer * buff, const void * string_utf8,
+		uint16_t size_in_bytes) {
+
+	// send length first
+	uint16_t nsize = htons(size_in_bytes);
+	buff->Push(&nsize, sizeof(uint16_t));
+
+	buff->Push(string_utf8, size_in_bytes);
+}
+
+void pack_bytes(Buffer * buff, const void * data, jint size) {
+	buff->Push(data, size);
+}
+
+#endif	/* _BUFFPACK_H */
diff -uN android-re-agent/long.cpp android-re-agent.bak2/long.cpp
--- android-re-agent/long.cpp	1970-01-01 01:00:00.000000000 +0100
+++ android-re-agent.bak2/long.cpp	2013-11-20 09:16:05.348019814 +0100
@@ -0,0 +1,103 @@
+#define LOG_TAG "LongTest2 long.cpp"
+#define ERR_PREFIX "ERR"
+#include <utils/Log.h>
+#include <cutils/log.h>
+#include <stdio.h>
+#include "jni.h"
+#include <string>
+#include "netref.h"
+#include "Dalvik.h"
+#include "JniInternal.h"
+
+
+jint add(JNIEnv *env, jobject thiz, jint x, jint y){
+	ALOG(LOG_INFO,"HAIYANG","ssss native jni in add %d", x+y);
+	return x + y;
+}
+
+jint substraction(JNIEnv *env, jobject thiz, jint x, jint y){
+
+	return x - y;
+}
+
+jfloat multiplication(JNIEnv *env, jobject thiz, jint x, jint y){
+
+	return (float)x * (float)y;
+}
+
+jfloat division(JNIEnv *env, jobject thiz, jint x, jint y){
+	return (float)x/(float)y;
+}
+
+static const char *classPathName = "com/inspur/test2/MainActivity";
+
+static JNINativeMethod methods[]= {
+	
+	{"add", "(II)I", (void*)add},
+	{"substraction", "(II)I", (void*)substraction},
+	{"multiplication", "(II)F", (void*)multiplication},
+	{"division", "(II)F", (void*)division},
+};
+
+
+typedef union{
+	JNIEnv* env;
+	void* venv;
+}UnionJNIEnvToVoid;
+
+
+
+static int registerNativeMethods(JNIEnv* env, const char* className,
+	JNINativeMethod* gMethods, int numMethods){
+
+	jclass clazz;
+	clazz = env->FindClass(className);
+
+	if (clazz == NULL)
+		return JNI_FALSE;
+	if (env->RegisterNatives(clazz, gMethods, numMethods)<0)
+		return JNI_FALSE;
+	return JNI_TRUE;
+
+}
+
+
+static int registerNatives(JNIEnv *env){
+
+	if (!registerNativeMethods(env, classPathName,
+		methods, sizeof(methods)/sizeof(methods[0])))
+	{
+		return JNI_FALSE;
+	}
+
+	return JNI_TRUE;
+
+}
+
+
+
+jint JNI_OnLoad(JavaVM* vm, void* reserved){
+
+	UnionJNIEnvToVoid uenv;
+	uenv.venv = NULL;
+	jint result = -1;
+	JNIEnv *env = NULL;
+
+	if (vm->GetEnv(&uenv.venv, JNI_VERSION_1_4) != JNI_OK){
+		goto bail;
+	}
+	
+	env = uenv.env;
+
+	env = uenv.env;
+
+	if (registerNatives(env) != JNI_TRUE){
+
+		goto bail;
+	}
+
+	result = JNI_VERSION_1_4;
+
+bail:
+	return result;
+}
